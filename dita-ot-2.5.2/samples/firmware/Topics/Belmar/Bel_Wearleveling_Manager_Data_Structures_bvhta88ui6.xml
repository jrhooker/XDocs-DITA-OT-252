<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysSchema/dita/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="Wearleveling_Manager_Data_Structures_bvhta88ui6" xml:lang="en-US">
  <title>Wearleveling Manager Data Structures</title>

  <body>
    <p>The following sections describe the data structures
    utilized by the Wearleveling Manager.</p>

    <section id="Block_Information_bwhta88ui6"><title>Virtual Block Information</title><p>Virtual Block Info data structure is used to store
    virtual block information. Memory for these structures is statically
    allocated in the controller memory as an array of <varname>virtual_block_info_t </varname>and
    each array element is queued to the corresponding lists based on block
    state. Block information data structure is shown in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Virtual_Block_Information_Data_Structure_1huztvq86">
    </xref>.</p><fig id="fig_Virtual_Block_Information_Data_Structure_1huztvq86">
        <title>Virtual Block Information Data
        Structure</title>

        <codeblock>
typedef struct virtual_block_info_s
{
    list_head_t blockList;
    block_state_t block_state;
    u32 validDataFrameCount;
    u32 eraseCount;
    u32 flashAddr;
    u32 badBlockBitMap[8];
    u32 grownBadBlockBitMap[8];
    u16 badBlockCount;
    u8 grownBadBlockCount;
    u8 eccContextIndex;
    u32 readCount;
} virtual_block_info_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>blockList</pt>

          <pd>Used to queue the structure to the
          corresponding list such as FreeList or DirtyList or
          GarbageList.</pd>
        </plentry>

        <plentry>
          <pt>block_State</pt>

          <pd>Current block state(Erased/USED/BAD
          etc), status and priority.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameCount</pt>

          <pd>Number of valid data frames in the
          current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>eraseCount</pt>

          <pd>Erase count of the current virtual
          block.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>Flash address of the current virtual
          block that is generated with channel, target, and block number.</pd>
        </plentry>

        <plentry>
          <pt>badBlockBitmap</pt>

          <pd>Bad block bitmap represents bad
          blocks in current virtual block. 0: bad block, 1: good block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockBitMap</pt>

          <pd>Grown bad block bitmap represents
          grown bad blocks in current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>badBlockCount</pt>

          <pd>Number of bad blocks in current
          virtual block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockCount</pt>

          <pd>Number of grown bad blocks in
          current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>eccContextIndex</pt>

          <pd>Number of grown bad blocks in
          current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>readCount</pt>

          <pd>Read count of the current
          block.</pd>
        </plentry>
      </parml></section>

    <section id="Valid_Data_Frame_Count_and_Valid_Data_Fr_c0hta88ui6"><title>Valid Data Frame Count and Valid Data Frame Bit
    Map</title><p>Valid data frame count represents number
    of valid data frames within a flash block. Valid data frame count is
    maintained for every virtual block. When a virtual block is allocated for
    writing, it is initialized to N where N = number of virtual pages * data
    frames per virtual page, assuming that the flash block will be filled
    without any interrupt. It is decremented when a data frame is obsoleted.
    Valid data frame count is used in the Wearleveling algorithm to re-arrange
    entries in DirtyList.</p><p>Valid data frame bitmap
    represents valid data frames within a virtual block, one bit for every
    data frame. 0 indicates data frame is not valid, 1 indicates valid. Valid
    data frame bitmap is used during garbage collection to move all valid data
    frames to new virtual block. Memory for these lists is statically
    allocated in the controller memory. Valid data frame bit map is maintained
    for every virtual block and it varies with page size. Page size and the
    number of data frames per virtual page are configured during runtime based
    on flash geometry. Valid data frame bitmap size is configured dynamically
    based on virtual page size. Physical block number, virtual page number,
    and data frame number within a virtual page are used to access a bit
    field</p></section>

    <section id="Configuration_Information_c1hta88ui6"><title>Configuration Information</title><p>General Wearleveling Manager configuration information
    such as the flash configuration, DDR address map, bit operational
    commands, wearleveling parameters, and etc are stored in a global variable
    of type <i>wearlvl_mgr_config_t </i>called <i>config</i>. The <i>wearlvl_mgr_config_t</i> structure is shown in
    <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Wearleveling_Manager_Configuration_Data__2huzty3iy">
    </xref></p><fig id="fig_Wearleveling_Manager_Configuration_Data__2huzty3iy">
        <title>Wearleveling Manager Configuration Data
        Structure</title>
      </fig><fig id="Wearleveling_Manager_Configuration_Data__c2hta88ui6">
        <codeblock>
typedef struct  wearlvl_mgr_config_s
{
    u8 opState;
    u8 badBlockScanEnabled;
    u16 virtualBlockSize;
    u16 numberOfActiveVirtualTargets;
    u16 validDataFrameBitmapSize;
    u16 gcPausedStatus;
    u8 dataFramesPerPage;
    u16 dataFramesPerVirtualPage;
    u8 startingLun;
    u8 notContiguousChannels;
    u16 totalLUNS;
    u16 myTotalLUNS;
    u32 totalAdvertizedSize;
    u32 sparePercentage;
    ddr_addr_map_t ddrAddrMap;
    flash_config_t flashConfig;
    bit_op_cmds_t bitOpCmds;
    u8 physical2LogicalChannelMap[MAX_CHANNELS];
} wearlvl_mgr_config_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>opState</pt>

          <pd>Current operational state of the
          Wearleveling Manager.</pd>
        </plentry>

        <plentry>
          <pt>badBlockScanEnabled</pt>

          <pd>Used to find out the first time
          power up initialization is done by scanning bad blocks or erasing
          flash blocks.</pd>
        </plentry>

        <plentry>
          <pt>virtualBlockSize</pt>

          <pd>Virtual block size in-terms physical
          blocks.</pd>
        </plentry>

        <plentry>
          <pt>numberOfActiveVirutalTargets</pt>

          <pd>Number of active virtual
          blocks.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameBitmapSize</pt>

          <pd>Valid data frame bitmap size per
          virtual block calculated, based on flash geometry.</pd>
        </plentry>

        <plentry>
          <pt>gcPausedStatus</pt>

          <pd>Garbage collection activity status.
          Shows whether GC is running or not.</pd>
        </plentry>

        <plentry>
          <pt>dataFramesPerPage</pt>

          <pd>Number of data frames per flash
          physical page.</pd>
        </plentry>

        <plentry>
          <pt>dataFramesPerVirtualPage</pt>

          <pd>Number of data frames per virtual
          page.</pd>
        </plentry>

        <plentry>
          <pt>startingLUN</pt>

          <pd>Starting LUN number to be managed by
          the current manager.</pd>
        </plentry>

        <plentry>
          <pt>notContiguousChannel</pt>

          <pd>Flag to keep track all flash
          channels are populated in the system.</pd>
        </plentry>

        <plentry>
          <pt>totalLUNs</pt>

          <pd>Total number of flash targets
          connected to the controller.</pd>
        </plentry>

        <plentry>
          <pt>myTotalLUNs</pt>

          <pd>Total number of flash targets to be
          managed by the current manager.</pd>
        </plentry>

        <plentry>
          <pt>totalAdvertizedSize</pt>

          <pd>Total advertised size of the device
          in 4KB blocks.</pd>
        </plentry>

        <plentry>
          <pt>sparePercentage</pt>

          <pd>Percentage of space reserved for
          over provision.</pd>
        </plentry>

        <plentry>
          <pt>ddrAddrMap</pt>

          <pd>Global data structures stored in the
          controller's memory (DDR) address map.</pd>
        </plentry>

        <plentry>
          <pt>flashConfig</pt>

          <pd>Flash configuration data.</pd>
        </plentry>

        <plentry>
          <pt>bitOpCmds</pt>

          <pd>Bit operation commands.</pd>
        </plentry>

        <plentry>
          <pt>physical2LogicalChannelMap</pt>

          <pd>Physical to Logical channel
          mapping.</pd>
        </plentry>
      </parml></section>

    <section id="State_Header_Structure_c3hta88ui6"><title>State
    Header Structure</title><p>The Wearleveling Manager has
    multiple context structures and all contain a header structure to store
    generic state information. This structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_State_Header_Structure_3huzty3iy">
    </xref>.</p><fig id="fig_State_Header_Structure_3huzty3iy">
        <title>State Header Structure</title>
      </fig><fig id="State_Header_Structure_c4hta88ui6">
        <codeblock>typedef struct state_header {
    single_list_head_t   list;
    u32                  state : 8;
    u32                  stateType : 4;
    u32                  status: 6;
    u32                  reserved: 14;
} state_header_t;</codeblock>
      </fig><parml>
        <plentry>
          <pt>list</pt>

          <pd>Single list head used for
          queuing.</pd>
        </plentry>

        <plentry>
          <pt>state</pt>

          <pd>State of the context structure.</pd>
        </plentry>

        <plentry>
          <pt>stateType</pt>

          <pd>Type of the context structure.</pd>
        </plentry>

        <plentry>
          <pt>status</pt>

          <pd>Status bits related to the current
          state.</pd>
        </plentry>
      </parml></section>

    <section id="Block_Open_State_Structure_c5hta88ui6"><title>Block Open State Structure</title><p>The Block Open State structure is used to maintain
    context information for each opened virtual block. Memory for these
    structures is allocated as an array of <varname>block_open_state_t</varname> structures from
    localMemory pool and one array element per each virtual target. This
    structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Block_Open_State_Structure_4huzty3iy">
    </xref>.</p><fig id="fig_Block_Open_State_Structure_4huzty3iy">
        <title>Block Open State Structure</title>
      </fig><fig id="Block_Open_State_Structure_c6hta88ui6">
        <codeblock>typedef struct  block_open_state_s
{
    state_header_t header;
    reg64 blockInfoAddr;
    union
    {
        reg64 listHeadAddr;
        struct {
            block_state_t blockState;
            u32 validDataFrameCount;
        };
    };
    u32 eraseCounter;
    u32 flashAddr;
    u32 badBlockBitmap[8];
    u32 grownBadBlockBitmap[8];
    u16 badBlockCount;
    u8 grownBadBlockCount;
    u8 eccContextIndex;
    u32 logicalTarget : 16;
    u32 freeBlockStatus:8;
    u32 outMsgQ : 8;
    u32 tag[2];
} block_open_state_t;</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>blockInfoAddr</pt>

          <pd>The controller memory address of the
          block information.</pd>
        </plentry>

        <plentry>
          <pt>listHeadAddr</pt>

          <pd>The controller memory address of the
          list head.</pd>
        </plentry>

        <plentry>
          <pt>blockState</pt>

          <pd>Current state of the block and block
          status.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameCount</pt>

          <pd>Number of valid data frames exists
          in the current block.</pd>
        </plentry>

        <plentry>
          <pt>eraseCount</pt>

          <pd>Erase count of the current
          block.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>Flash address of the current block
          that is generated with channel, target and block number.</pd>
        </plentry>

        <plentry>
          <pt>badBlockBitmap</pt>

          <pd>Bad block bitmap represents bad
          blocks in current virtual block. 0: bad block, 1: good block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockBitMap</pt>

          <pd>Grown bad block bitmap represents
          grown bad blocks in current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>badBlockCount</pt>

          <pd>Number of bad blocks in current
          virtual block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockCount</pt>

          <pd>Number of grown bad blocks in
          current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>eccContextIndex</pt>

          <pd>Number of grown bad blocks in
          current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>virtualTarget</pt>

          <pd>Virtual target number.</pd>
        </plentry>

        <plentry>
          <pt>freeBlockStatus</pt>

          <pd>Free block availability status.</pd>
        </plentry>

        <plentry>
          <pt>outMsgQ</pt>

          <pd>Outbound message queue index to send
          completion.</pd>
        </plentry>

        <plentry>
          <pt>Tags</pt>

          <pd>Storage for tags from block open
          request.</pd>
        </plentry>
      </parml></section>

    <section id="Obsolete_Data_Frame_State_Structure_c7hta88ui6"><title>Obsolete Data Frame State Structure</title><p>The Obsolete Data Frame State structure is used to
    maintain context information for each outstanding ObsoleteDataFrame
    message. Memory for these structures is allocated as an array of <i>obsolete_data_frame_state_t</i> structures from
    localMemory pool, each array element is added to a pool of free Obsolete
    Data Frame State structures after system initialization. This structure is
    described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Obsolete_Data_Frame_State_structure_5huzu48rw">
    </xref>.</p><fig id="fig_Obsolete_Data_Frame_State_structure_5huzu48rw">
        <title>Obsolete Data Frame State
        Structure</title>
      </fig><fig id="Obsolete_Data_Frame_State_structure_c8hta88ui6">
        <codeblock>typedef struct  obsolete_data_frame_state_s
{
    state_header_t header;
    reg64 blockInfoAddr;
    reg64 listHeadAddr;
    u32 virtualTarget:8;
    u32 dataFrameNumber:8;
    u32 flashBlockIndex:16;
    u32 flashAddr;
    block_state_t block_state;
    u32 validDataFrameCount;
    u32 eraseCount;    
} obsolete_data_frame_state_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>blockInfoAddr</pt>

          <pd>The controller memory address of the
          block information.</pd>
        </plentry>

        <plentry>
          <pt>listHeadAddr</pt>

          <pd>The controller memory address of the
          list head.</pd>
        </plentry>

        <plentry>
          <pt>virtualTarget</pt>

          <pd>Virtual target of current obsolete
          data frame request.</pd>
        </plentry>

        <plentry>
          <pt>dataFrameNumber</pt>

          <pd>Data frame number to be
          obsoleted.</pd>
        </plentry>

        <plentry>
          <pt>flashBlockIndex</pt>

          <pd>Flash block index where valid data
          frame count and priority is updated.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>flash address of the data frame that
          is being obsoleted.</pd>
        </plentry>

        <plentry>
          <pt>blockState</pt>

          <pd>Current state of the block and block
          status.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameCount</pt>

          <pd>Valid data frame count for the flash
          block.</pd>
        </plentry>

        <plentry>
          <pt>eraseCount</pt>

          <pd>Erase count of the current
          block.</pd>
        </plentry>
      </parml></section>

    <section id="Block_Open_State_Structure_c5hta88ui6"><title>Virtual Target State Structure</title><p>The Virtual Target State structure is used by the
    garbage collection and power up initialization to maintain context
    information for each virtual target. Memory for these structures is
    allocated as an array of <varname>virtual_target_state_t</varname> structures
    from localMemory pool and one array element per each virtual target. This
    structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Virtual_target_State_Structure_6huzu48rw">
    </xref>.</p><fig id="fig_Virtual_target_State_Structure_6huzu48rw">
        <title>Virtual Target State Structure</title>
      </fig><fig id="Block_Open_State_Structure_c6hta88ui6">
        <codeblock>typedef struct  block_open_state_s
{
    state_header_t header;
    reg64 blockInfoAddr;
    reg64 listHeadAddr;
    block_state_t blockState;
    u32 validDataFrameCount;
    u32 eraseCounter;
    u32 flashAddr;
    u32 badBlockBitmap[8];
    u32 grownBadBlockBitmap[8];
    u16 badBlockCount;
    u8 grownBadBlockCount;
    u8 eccContextIndex;
    u16 erasedBlockCount;
    u16 blockNum;
    u16 activeDataFrameNum;
    u16 targetsReadyForErase;
    u16 gcActiveTargets;
    u16 pendingCpl;
    u8 validDataFrameBitmapDWORDIndex;
    u8 activeVDFBitmapDWORDIndex;
    u16 maxNumOfDataFramesInVirtualPage;
    u16 startingTarget;
    u16 endingTarget;
    u16 activeTarget;
    u16 activePlane;
    u32 validDataFrameBitmap[VALID_DATA_FRAME_BITMAP_ITERATION_LENGTH/sizeof(u32)];
    u16 startingDataFrameBuffIndex;
    u16 erasedDataFrames;    
} block_open_state_t;</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>blockInfoAddr</pt>

          <pd>The controller memory address of the block information.</pd>
        </plentry>

        <plentry>
          <pt>listHeadAddr</pt>

          <pd>The controller memory address of the list head.</pd>
        </plentry>

        <plentry>
          <pt>blockState</pt>

          <pd>Current state of the block and block status.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameCount</pt>

          <pd>Number of valid data frames exists in the current block.</pd>
        </plentry>

        <plentry>
          <pt>eraseCount</pt>

          <pd>Erase count of the current block.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>Flash address of the current block that is generated with
          channel, target and block number.</pd>
        </plentry>

        <plentry>
          <pt>badBlockBitmap</pt>

          <pd>Bad block bitmap represents bad blocks in current virtual block.
          0: bad block, 1: good block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockBitMap</pt>

          <pd>Grown bad block bitmap represents grown bad blocks in current
          virtual block. </pd>
        </plentry>

        <plentry>
          <pt>badBlockCount</pt>

          <pd>Number of bad blocks in current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>grownBadBlockCount</pt>

          <pd>Number of grown bad blocks in current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>eccContextIndex</pt>

          <pd>Number of grown bad blocks in current virtual block.</pd>
        </plentry>

        <plentry>
          <pt>erasedBlockCount</pt>

          <pd>Number of erased physical blocks in a virtual block.</pd>
        </plentry>

        <plentry>
          <pt>blockNum</pt>

          <pd>Active vitual block number being initialized (during power up
          initialization).</pd>
        </plentry>

        <plentry>
          <pt>activeDataFrameNum</pt>

          <pd>Active data frame number.</pd>
        </plentry>

        <plentry>
          <pt>targetsReadyForErase</pt>

          <pd>Number of physical targets ready for erase.</pd>
        </plentry>

        <plentry>
          <pt>gcActiveTargets</pt>

          <pd>Number of physical targets active in GC process.</pd>
        </plentry>

        <plentry>
          <pt>pendingCpl</pt>

          <pd>Pending data frame write completions.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameBitmapDWORDIndex</pt>

          <pd>Valid data frame bitmap dword index.</pd>
        </plentry>

        <plentry>
          <pt>activeVDFBitmapDWORDIndex</pt>

          <pd>Active valid data frame bitmap dword index.</pd>
        </plentry>

        <plentry>
          <pt>maxNumOfDataFramesInVirtualPage</pt>

          <pd>Max number of data frame within virtual page. This is based on
          ECC code rate.</pd>
        </plentry>

        <plentry>
          <pt>startingTarget</pt>

          <pd>Starting physical target in virtual target.</pd>
        </plentry>

        <plentry>
          <pt>endingTarget</pt>

          <pd>Ending physical target in virtual target.</pd>
        </plentry>

        <plentry>
          <pt>activeTarget</pt>

          <pd>Active physical target in virtual target.</pd>
        </plentry>

        <plentry>
          <pt>activePlane</pt>

          <pd>Active plane in physical target.</pd>
        </plentry>

        <plentry>
          <pt>validDataFrameBitmap</pt>

          <pd>Valid data frame bitmap.</pd>
        </plentry>

        <plentry>
          <pt>startingDataFrameBuffIndex</pt>

          <pd>Starting index to the data frame buffer handles array.</pd>
        </plentry>

        <plentry>
          <pt>erasedDataFrames</pt>

          <pd>Erased data frames in current virtual page. </pd>
        </plentry>
      </parml></section>

    <section id="Reclaim_Block_State_Structure_c9hta88ui6"><title>Reclaim Block State Structure</title><p>The Reclaim Block State structure is used to maintain
    context information for reclaim block process. Memory for these structures
    is allocated as an array of <i>recalaim_block_state_t</i> structures from
    localMemory pool and one array element per each target. This structure is
    described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Reclaim_Block_State_Structure_7huzu48rw">
    </xref>.</p><fig id="fig_Reclaim_Block_State_Structure_7huzu48rw">
        <title>Reclaim Block State Structure</title>
      </fig><fig id="Reclaim_Block_State_Structure_cahta88ui6">
        <codeblock>typedef struct reclaim_block_state_s
{
    state_header_t header;
    rb_read_header_t readHeaderData[16];
    u32 activeHeader : 4;
    u32 pendingFlashCpl : 4;
    u32 numPlanes : 4;
    u32 numHeaders : 4;
    u32 virtualTargetIndex : 6;
    u32 erasedPageCount : 4;
    u32 startingPlaneNum : 4;
    u32 flashAddr;
    union
    {
        u32 firstMsgHandle;
        u8 planeUncVectorStatus[4];
    }
    union
    {
        u32 prevMsgHandle;
        struct
        {
             u16 pendingDataFrameProcessing;
             u16 invalidLogicalAddrs;
        };
    };
    u16 firstDataFrameBuffOffset;
    u16 lastDataFrameLength;
} reclaim_block_state_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>readHeaderData</pt>

          <pd>Structure to keep track of read header data.</pd>
        </plentry>

        <plentry>
          <pt>activeHeader</pt>

          <pd>Active header which is in the process of sending flash interface
          message.</pd>
        </plentry>

        <plentry>
          <pt>pendingFlashCpl</pt>

          <pd>Pending flash completions.</pd>
        </plentry>

        <plentry>
          <pt>numPlanes</pt>

          <pd>Number of planes involved in current flash read request.</pd>
        </plentry>

        <plentry>
          <pt>numHeaders</pt>

          <pd>Number of read headers involved in current flash read
          request.</pd>
        </plentry>

        <plentry>
          <pt>virtualTargetIndex</pt>

          <pd>Virtual target index.</pd>
        </plentry>

        <plentry>
          <pt>erasedPageCount</pt>

          <pd>Erased page count in current physical target.</pd>
        </plentry>

        <plentry>
          <pt>startingPlaneNum</pt>

          <pd>Starting plane number in current flash read request.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>Garbage collection active block flash address.</pd>
        </plentry>

        <plentry>
          <pt>firstMsgHandle</pt>

          <pd>First outbound message handle. This is used to post the message
          to the flash interface.</pd>
        </plentry>

        <plentry>
          <pt>prevMsgHandle</pt>

          <pd>Previous message handle. This is used to create chained
          messages.</pd>
        </plentry>

        <plentry>
          <pt>pendingDataFrameProcessing</pt>

          <pd>Number of data frames that are still in processing.</pd>
        </plentry>

        <plentry>
          <pt>invalidLogicalAddrs</pt>

          <pd>Number of data frames which has invalid logical address.</pd>
        </plentry>

        <plentry>
          <pt>prevMsgDW6</pt>

          <pd>Previous message DW6. This is used to update last plane
          bit.</pd>
        </plentry>
      </parml></section>

    <section id="Power_On_Init_State_Structure_cbhta88ui6"><title>Read Header Structure</title><p>The read header structure is used to maintain read
    header information required to read multi-plane data when the garbage
    collection is active. <i>rb_read_header_t</i>
    structure is part of <varname>reclaim_block_state_t</varname> structure
    This structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Multi_Plane_Structure_8huzu48rw">
    </xref>.</p><fig id="fig_Multi_Plane_Structure_8huzu48rw">
        <title>Read Header Structure</title>
      </fig><fig id="Power_On_Init_State_Structure_cchta88ui6">
        <codeblock>typedef struct rb_read_header_s
{
    u32 startECCChunkNum : 4;
    u32 numECCChunks : 4;
    u32 numDataFrameBuffs : 4;
    u32 planeNum : 4;
    u32 lastBufferSpan:1;
    u32 firstDataFrameBuffPartial : 1;
    u32 activeDataFrameBuff : 4;
    u32 startDataFrameNum : 10;
    u16 firstDataFrameDumpCount;
    u8  readUncBitVector;
    u8  erasedDataFrames: 4;
    u8  physicalPlaneNum : 4;
}multi_plane_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>startECCChunkNum</pt>

          <pd>Starting valid ECC chunk number in current plane.</pd>
        </plentry>

        <plentry>
          <pt>numECCChunks</pt>

          <pd>Number of valid ECC chunks in current plane.</pd>
        </plentry>

        <plentry>
          <pt>numDataFrameBuffs</pt>

          <pd>Number of valid data frame buffers in current plane.</pd>
        </plentry>

        <plentry>
          <pt>planeNum</pt>

          <pd>Logical plane number</pd>
        </plentry>

        <plentry>
          <pt>lastBufferSpan</pt>

          <pd>Flag to keep track last data frame spans to next plane.</pd>
        </plentry>

        <plentry>
          <pt>firstDataFrameBuffPartial</pt>

          <pd>First data frame in current plane is partial.</pd>
        </plentry>

        <plentry>
          <pt>activeDataFrameBuff</pt>

          <pd>Active data frame buffer.</pd>
        </plentry>

        <plentry>
          <pt>startDataFrameNum</pt>

          <pd>Starting data frame number w.r.t to virtual page.</pd>
        </plentry>

        <plentry>
          <pt>firstDataFrameDumpCount</pt>

          <pd>First data frame dump count - number of bytes to dump before
          transferring data to data frame buffer.</pd>
        </plentry>

        <plentry>
          <pt>readUncBitVector</pt>

          <pd>Read uncorrectable bit vector.</pd>
        </plentry>

        <plentry>
          <pt>erasedDataFrames</pt>

          <pd>Erased or invalid data frames in current header.</pd>
        </plentry>

        <plentry>
          <pt>physicalPlaneNum</pt>

          <pd>Physical plane number.</pd>
        </plentry>
      </parml></section>

    <section id="Power_On_Init_State_Structure_cbhta88ui6"><title>Data Frame State Structure</title><p>The Data Frame State structure is used to maintain
    context information when the garbage collection is processing at data
    frame level. Memory for these structures is allocated as an array of
    <varname>dataframe_state_t</varname> structure
    from localMemory pool. This structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Data_Frame_State_Structure_9huzu48rw">
    </xref>.</p><fig id="fig_Data_Frame_State_Structure_9huzu48rw">
        <title>Data Frame State Structure</title>
      </fig><fig id="Power_On_Init_State_Structure_cchta88ui6">
        <codeblock>typedef struct dataframe_state_s
{
    state_header_t header;
    u16 virtualTarget;
    u16 dataFrameNumber;
    u8 readHeaderNum;
    u8 virtualTargetIndex;
    u16 reserved;
    u32 logicalAddr;
    u32 lookupTableEntry[3];
} dataframe_state_t;
</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>virtualTarget</pt>

          <pd>Virtual target of this data frame.</pd>
        </plentry>

        <plentry>
          <pt>dataFrameNumber</pt>

          <pd>Data frame number within virtual page.</pd>
        </plentry>

        <plentry>
          <pt>readHeaderNum</pt>

          <pd>Read header number.</pd>
        </plentry>

        <plentry>
          <pt>virtualTargetIndex</pt>

          <pd>Virtual target index - physical block index within virtual
          target.</pd>
        </plentry>

        <plentry>
          <pt>logicalAddr</pt>

          <pd>Logical address of this data frame.</pd>
        </plentry>

        <plentry>
          <pt>lookupTableEntry</pt>

          <pd>Lookup table entry of this data frame.</pd>
        </plentry>
      </parml></section>

    <section id="Power_On_Init_State_Structure_cbhta88ui6"><title>Power Up Init State Structure</title><p>The Power Up Init State structure is used to maintain
    context information for first time power on initialization. One state
    structure per each target. Memory for these structures is allocated as an
    array of <varname>power_up_init_state_t</varname> structure from
    localMemory pool. After power on initialization, memory is released back
    to the local memory pool. This structure is described in <xref href="#Wearleveling_Manager_Data_Structures_bvhta88ui6/fig_Power_Up_Init_State_Structure_ahuzu48rx">
    </xref>.</p><fig id="fig_Power_Up_Init_State_Structure_ahuzu48rx">
        <title>Power Up Init State Structure</title>
      </fig><fig id="Power_On_Init_State_Structure_cchta88ui6">
        <codeblock>typedef struct  power_up_init_state_s
{
    state_header_t header;
    u32 metaData1stDword[4];
    u32 flashAddr;
    u64 dataFrameBuffAddr[4];
    u16 virtualBlockIndex;
    u16 blockNumber;
    u16 virtualTarget;
    u8 numPlanes;
    u8 lastPlane;
    u8  startingPlaneNum;
    u8  validPlaneBitmap;
    u8  pendingCpl;
    u32 firstMsgHandle;
    u32 prevMsgHandle;
} power_up_init_state_t, system_format_state_t;</codeblock>
      </fig><parml>
        <plentry>
          <pt>header</pt>

          <pd>State header structure.</pd>
        </plentry>

        <plentry>
          <pt>metaData1stDword</pt>

          <pd>Place hold to read first dword of flash physical page metadata.
          First dword has bad block signature.</pd>
        </plentry>

        <plentry>
          <pt>flashAddr</pt>

          <pd>Flash address of the block being initialized.</pd>
        </plentry>

        <plentry>
          <pt>dataFrameAddress</pt>

          <pd>Data frame address to read flash physical page metadata.</pd>
        </plentry>

        <plentry>
          <pt>virtualBlockIndex</pt>

          <pd>Block index within virtual block.</pd>
        </plentry>

        <plentry>
          <pt>blockNumber</pt>

          <pd>Block number within virtual target.</pd>
        </plentry>

        <plentry>
          <pt>virtualTarget</pt>

          <pd>Virtual target number.</pd>
        </plentry>

        <plentry>
          <pt>numPlanes</pt>

          <pd>Number of planes involved in current operation.</pd>
        </plentry>

        <plentry>
          <pt>lastPlane</pt>

          <pd>Flag to keep track of last plane operation.</pd>
        </plentry>

        <plentry>
          <pt>startingPlaneNum</pt>

          <pd>Starting plane number.</pd>
        </plentry>

        <plentry>
          <pt>validPlaneBitmap</pt>

          <pd>Bitmap to represent valid planes in current target.</pd>
        </plentry>

        <plentry>
          <pt>pendingCpl</pt>

          <pd>Pending flash completions in current target.</pd>
        </plentry>

        <plentry>
          <pt>firstMsgHandle</pt>

          <pd>First outbound message handle. This is used to post the message
          to the flash interface.</pd>
        </plentry>

        <plentry>
          <pt>prevMsgHandle</pt>

          <pd>Previous message handle. This is used to create chained
          messages.</pd>
        </plentry>

        <plentry>
          <pt>prevMsgDW6</pt>

          <pd>Previous message DW6. This is used to update last plane
          bit.</pd>
        </plentry>
      </parml></section>
  </body>
</topic>