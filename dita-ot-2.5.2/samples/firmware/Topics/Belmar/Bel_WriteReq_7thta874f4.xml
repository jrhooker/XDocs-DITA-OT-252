<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysConfig/backup/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="WriteReq_7thta874f4" xml:lang="en-US">
  <title>WriteReq</title>

  <body>
    <section id="Write_Cache_Buffer_Disabled_7uhta874f4"><title>Write Cache Buffer Disabled</title> <p>The Write request writes data and metadata, if
    applicable, to the NVM controller for the logical blocks indicated. The
    Lookup Manager will send write completion to the Data Manager after the
    data has been successfully written to flash.</p> <p>When the volatile write cache is enabled, the Lookup
    Manager will send write completion to the Data Manager when a lookup table
    entry lock is granted; that is, before the data is written to flash.</p>
    <fig id="Write_Request_Control_Write_Cache_Disabl_7vhta874f4">
        <title>Write Request Control (Write Cache
        Disabled)</title>

        <image href="Graphics/bel_lkp_write_cache_diabled.svg" placement="break" width="5.5in"/>
      </fig> <table id="_7whta874f4">
        <title>Write Request Control (Write Cache
        Disabled)</title>

        <tgroup cols="3">
          <colspec colname="c1" colwidth="5*"/>

          <colspec colname="c2" colwidth="23*"/>

          <colspec colname="c3" colwidth="72*"/>

          <thead>
            <row>
              <entry>No.</entry>

              <entry>Message</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><p> <b otherprops="bold">1</b> </p></entry>

              <entry><p> <b otherprops="bold">CmdReady64</b>
              </p></entry>

              <entry><p>The write
              command is received by one of the Data Managers.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">2</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteLockReq</b>
              </p></entry>

              <entry><p>The Data
              Manager issues a write lock for the Data Frame range specified
              in the write request.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">3</b> </p></entry>

              <entry><p> <b otherprops="bold">LockCpl</b>
              </p></entry>

              <entry><p>The write
              lock is granted by the Locking Manager.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">4</b> </p></entry>

              <entry><p> <b otherprops="bold">BufferAllocCpl</b>
              </p></entry>

              <entry><p>The Data
              Manager processes buffer completions from the buffer manager and
              gets data frame buffer address.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">5</b> </p></entry>

              <entry><p> <b otherprops="bold">BufferAlloc</b>
              </p></entry>

              <entry><p>The Data
              Manager send bufferAlloc message to the Buffer Manager for
              future use.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">6</b> </p></entry>

              <entry><p> <b otherprops="bold">IngressSectorDMA</b> </p></entry>

              <entry><p>The Data
              Manager issues ingress DMA requests to transfer data from host
              memory to the Data Frame buffer.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">7</b> </p></entry>

              <entry><p> <b otherprops="bold">DMACpl</b>
              </p></entry>

              <entry><p>The ingress
              DMA replies to the Data Managers DMA request with a DMA
              completion when the data has been transferred.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">8</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteReq</b>
              </p></entry>

              <entry><p>The Data
              Manager issues a write request to the Lookup
              Manager.</p></entry>
            </row>

            <row>
              <entry/>

              <entry><p> <b otherprops="bold">Internal
              Operation</b> </p></entry>

              <entry><p>Upon the
              receipt of the WRITE_REQ_OPCODE from Data Manager, the Lookup
              Manager allocates a data frame structure and copies logical
              address, data frame buffer address, outbound message queue,
              updatedHostLba (which is partial data frame write info), and
              forces unit access to the data frame structure.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">9</b> </p></entry>

              <entry><p> <b otherprops="bold">dataNetworkMoveInAndLock</b> </p></entry>

              <entry><p>The Lookup
              Manager issues a memory read with lock request to the data
              network to fetch lookup table entry</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">10</b> </p></entry>

              <entry><p> <b otherprops="bold">dataNetworkCpl</b>
              </p></entry>

              <entry><p>The Lookup
              Manager receives data network completion for the read and lock
              request.</p></entry>
            </row>

            <row>
              <entry/>

              <entry/>

              <entry><p>If lock is
              not granted, go to step 9 until lock is granted.</p></entry>
            </row>

            <row>
              <entry/>

              <entry><p> <b otherprops="bold">Internal
              Operation</b> </p></entry>

              <entry><p>Lookup
              Manager will do the following:</p> <p>1.
              Update the namespace utilization according the data frame being
              written (that is, partial or full).</p> <p>2.
              Update the partialDataFrameBitmap in case of partial data frame
              write.</p> <p>3. Assign the new flash address
              for the data frame and increment the internal data structure to
              point to the next available flash address. While assigning for a
              new flash address, the Lookup Manager will handle the cases
              below:</p> <ul>
                  <li id="d1e1803"><p>Since a data frame can span two flash
                  pages, firmware will keep track of the offset within the
                  current flash page and assign one flash address or two flash
                  addresses for the data frame.</p></li>

                  <li id="d1e1809"><p>Last data frame of a virtual page. The
                  current design does not support spanning between virtual
                  pages, therefore, it is possible to have unused data area at
                  the end of the virtual page. When there’s not enough space
                  at the end of the virtual page to fit another data frame,
                  the Lookup Manager will assign a new flash address based on
                  the next virtual page.</p></li>

                  <li id="d1e1815"><p>In case of multi-plane writes, there are
                  fields in the LUN state structure to be used to notify Write
                  Manager of the multi-plane writes. If single-plane
                  firstMultiPlaneRequest and lastMultiPlaneRequest are both
                  set to 1, for 1st plane of a multi-plane request,
                  firstMultiPlaneRequest = 1 while lastMultiPlaneRequest = 0.
                  For middle planes, firstMultiPlaneRequest = 0 and
                  lastMultiPlaneRequest = 0. For last plane,
                  firstMultiPlaneRequest = 0 while lastMultiPlaneRequest = 1.
                  The write operation will be multi-plane when there’s a
                  pending write request while processing another write request
                  and multi-plane requirement (that is, start on even plane
                  and number of planes have to be even). The write of a data
                  frame will never start on odd plane unless it’s single-plane
                  only.</p></li>

                  <li id="d1e1821"><p>Getting the next available flash address
                  depends on the system’s configuration. In multi-plane, plane
                  field is incremented first before the page in the current
                  LUN state structure; the active LUN is moved to the next LUN
                  only if all the planes within the LUN have been written. In
                  single-plane, the page will be incremented first in the
                  current LUN structure and the active LUN is moved to the
                  next LUN.</p></li>
                </ul> <p>4. If full page frame data is not
              available, timer is enabled. Continue from step 11 when timer is
              expired or page frame is available.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">11</b> </p></entry>

              <entry><p> <b otherprops="bold">PageFrameWrite</b>
              </p></entry>

              <entry><p>A page frame
              write request is issued to the Write Manager. A page frame write
              request can contain multiple data frames. The current firmware
              will support page sizes of up to 32KB. This means a page frame
              request can contain up to 8 data frames.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">12</b> </p></entry>

              <entry><p> <b otherprops="bold">flashWrite</b>
              </p></entry>

              <entry><p>A write
              request is issued to the flash to write page frame.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">13</b> </p></entry>

              <entry><p> <b otherprops="bold">FlashOpCpl</b>
              </p></entry>

              <entry><p>The Flash
              Interface responds to the flash write request. Flash write
              completion comes to the Lookup Manager directly. If flash
              completion is good, go to step 18. If flash completion has an
              error, go to step 17.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">14</b> </p></entry>

              <entry><p> <b otherprops="bold">obsoleteErrorDataFrame</b> </p></entry>

              <entry><p>This
              Obsolete Data Frame request is issued to the Wearleveling
              Manager to obsolete the current data frame that failed. Then go
              back to the internal operation after step 10, to start a new
              writing process .</p> <p>There are three
              different cases for write error handling:</p> <p>1. Write error happens on lower page. The
              Lookup Manager will notify the Wearleveling Manager to obsolete
              the current data frame and rewrite the data frame to another
              location.</p> <p>2. Write error happens on
              upper page. The Lookup Manager will notify the Wearleveling
              Manager to obsolete the data frames held in the lower page and
              the current data frame and then rewrite both the lower and upper
              pages to a different location.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">15</b> </p></entry>

              <entry><p> <b otherprops="bold">BufferFree</b>
              </p></entry>

              <entry><p>When no
              longer needed, the Lookup Manager frees the Data Frame buffer.
              Depending on the flash configuration (that is, MLC flash with
              gaps in shared pages), this could mean that the buffer being
              freed is for the previous flash completions. </p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">16</b> </p></entry>

              <entry><p> <b otherprops="bold">ObsoleteDataFrame</b> </p></entry>

              <entry><p>The Obsolete
              Data Frame request is issued to the Wearleveling Manager. This
              function obsoletes the old data frame that has been
              overwritten.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">17</b> </p></entry>

              <entry><p> <b otherprops="bold">moveOutPosted</b>
              </p></entry>

              <entry><p>The Lookup
              Manager issues a memory write request to the data network to
              update lookup table entry with new flash address.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">18</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteCpl</b>
              </p></entry>

              <entry><p>The Lookup
              Manager responds to the Data Managers write request with a write
              completion.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">19</b> </p></entry>

              <entry><p> <b otherprops="bold">LockRelease</b>
              </p></entry>

              <entry><p>When all
              Data Frames have been transferred, the Data Manager releases the
              LBA range lock.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">20</b> </p></entry>

              <entry><p> <b otherprops="bold">CplQueueUpdate</b>
              </p></entry>

              <entry><p>The Data
              Manager sends a completion queue update request to the
              Completion Manager.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">21</b> </p></entry>

              <entry><p> <b otherprops="bold">CplQueueUpdateCpl</b> </p></entry>

              <entry><p>The
              Completion Manager replies back to the Admin Command Manager
              when the completion has been successfully sent to the
              host.</p></entry>
            </row>
          </tbody>
        </tgroup>
      </table></section>

    <section id="Write_Cache_Buffer_Enabled_7xhta874f4"><title>Write Cache Buffer Enabled</title> <p>The following shows a single plane write with a write
    cache buffer enabled. When the volatile write cache is enabled, the Lookup
    Manager will send a write completion to the Data Manager when a lookup
    table entry lock is granted, which is before the data is written to
    flash.</p> <fig id="Write_Request_Control_Flow_Write_Cache_E_7yhta874f4">
        <title>Write Request Control Flow (Write Cache
        Enabled)</title>

        <image href="Graphics/bel_lkp_write_cache_enabled.svg" placement="break" width="5.5in"/>
      </fig> <table id="_7zhta874f5">
        <title>Write Request Control Flow (Write Cache
        Enabled)</title>

        <tgroup cols="3">
          <colspec colname="c1" colwidth="5*"/>

          <colspec colname="c2" colwidth="23*"/>

          <colspec colname="c3" colwidth="72*"/>

          <thead>
            <row>
              <entry>No.</entry>

              <entry>Message</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><p> <b otherprops="bold">1</b> </p></entry>

              <entry><p> <b otherprops="bold">CmdReady64</b>
              </p></entry>

              <entry><p>The write
              command is received by one of the Data Managers.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">2</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteLockReq</b>
              </p></entry>

              <entry><p>The Data
              Manager issues a write lock for the Data Frame range specified
              in the write request.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">3</b> </p></entry>

              <entry><p> <b otherprops="bold">LockCpl</b>
              </p></entry>

              <entry><p>The write
              lock is granted by the Locking Manager.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">4</b> </p></entry>

              <entry><p> <b otherprops="bold">BufferAllocCpl</b>
              </p></entry>

              <entry><p>The Data
              Manager processes buffer completions from the buffer manager and
              gets a data frame buffer address.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">5</b> </p></entry>

              <entry><p> <b otherprops="bold">BufferAlloc</b>
              </p></entry>

              <entry><p>The Data
              Manager sends bufferAlloc message to the Buffer Manager for
              future use.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">6</b> </p></entry>

              <entry><p> <b otherprops="bold">IngressSectorDMA</b> </p></entry>

              <entry><p>The Data
              Manager issues ingress DMA requests to transfer data from host
              memory to the Data Frame buffer.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">7</b> </p></entry>

              <entry><p> <b otherprops="bold">DMACpl</b>
              </p></entry>

              <entry><p>The ingress
              DMA replies to the Data Managers DMA request with a DMA
              completion when the data has been transferred.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">8</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteReq</b>
              </p></entry>

              <entry><p>The Data
              Manager issues a write request to the Lookup
              Manager.</p></entry>
            </row>

            <row>
              <entry/>

              <entry><p> <b otherprops="bold">Internal
              Operation</b> </p></entry>

              <entry><p>Upon the
              receipt of the WRITE_REQ_OPCODE from Data Manager, the Lookup
              Manager allocates a data frame structure and copies the logical
              address, data frame buffer address, outbound message queue,
              updatedHostLba (which is partial data frame write info), and
              forces unit access to the data frame structure.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">9</b> </p></entry>

              <entry><p> <b otherprops="bold">dataNetworkMoveInAndLock</b> </p></entry>

              <entry><p>The Lookup
              Manager issues a memory read with lock request to the data
              network to fetch lookup table entry.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">10</b> </p></entry>

              <entry><p> <b otherprops="bold">dataNetworkCpl</b>
              </p></entry>

              <entry><p>Lookup
              Manager receives data network completion for the read and lock
              request.</p></entry>
            </row>

            <row>
              <entry/>

              <entry/>

              <entry><p>If lock is
              not granted, step 9 is repeated until lock is
              granted.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">11</b> </p></entry>

              <entry><p> <b otherprops="bold">WriteCpl</b>
              </p></entry>

              <entry><p>The Lookup
              Manager responds to the Data Managers write request with a write
              completion.</p></entry>
            </row>

            <row>
              <entry/>

              <entry><p> <b otherprops="bold">Internal
              Operation</b> </p></entry>

              <entry><p>Lookup
              Manager will do the following after sending the write completion
              back to the Data Manager:</p> <p>1. Update
              the namespace utilization according the data frame being written
              (that is, partial or full).</p> <p>2. Update
              the partialDataFrameBitmap in case of partial data frame
              write.</p> <p>3. Assign the new flash address
              for the data frame and increment the internal data structure to
              point to the next available flash address. While assigning for a
              new flash address, the Lookup Manager will handle the cases
              below:</p> <ul>
                  <li id="d1e2374"><p>Since a data frame can span two flash
                  page, firmware will keep track of the offset within the
                  current flash page and assign one flash address or two flash
                  addresses for the data frame.</p></li>

                  <li id="d1e2380"><p>Last data frame of a virtual page. The
                  current design does not support spanning between virtual
                  pages, therefore, it is possible to have unused data area at
                  the end of the virtual page. When there’s not enough space
                  at the end of the virtual page to fit another data frame,
                  the Lookup Manager will assign a new flash address based on
                  the next virtual page.</p></li>

                  <li id="d1e2386"><p>In a case of multi-plane writes, there
                  are fields in the LUN state structure to be used to notify
                  Write Manager of the multi-plane writes. If single-plane
                  firstMultiPlaneRequest and lastMultiPlaneRequest are both
                  set to 1, for 1st plane of a multi-plane request,
                  firstMultiPlaneRequest = 1 while lastMultiPlaneRequest = 0.
                  For middle planes, firstMultiPlaneRequest = 0 and
                  lastMultiPlaneRequest = 0. For last plane,
                  firstMultiPlaneRequest = 0 while lastMultiPlaneRequest = 1.
                  The write operation will be multi-plane when there’s a
                  pending write request while processing another write request
                  and multi-plane requirement (that is, start on even plane
                  and number of planes have to be even). The write of data
                  frame will never start on odd plane unless it’s single-plane
                  only.</p></li>

                  <li id="d1e2392"><p>Getting the next available flash address
                  depends on the system’s configuration. In multi-plane, plane
                  field is incremented first before page in the current LUN
                  state structure; the active LUN is moved to the next LUN
                  only if all the planes within the LUN have been written. In
                  single-plane, the page will be incremented first in the
                  current LUN structure and active LUN is moved to the next
                  LUN.</p></li>
                </ul> <p>4. If full page frame data is not
              available, timer is enabled. Continue from step 12 when timer is
              expired or page frame is available.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">12</b> </p></entry>

              <entry><p> <b otherprops="bold">PageFrameWrite</b>
              </p></entry>

              <entry><p>A Page frame
              write request is issued to the Write Manager.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">13</b> </p></entry>

              <entry><p> <b otherprops="bold">flashWrite</b>
              </p></entry>

              <entry><p>A write
              request is issued to the flash to write page frame.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">14</b> </p></entry>

              <entry><p> <b otherprops="bold">FlashOpCpl</b>
              </p></entry>

              <entry><p>The Flash
              Interface responds to the flash write request. Flash write
              completion comes to the Lookup Manager directly. If the flash
              completion is good, go to step 19. If there’s an error, go to
              step 18.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">15</b> </p></entry>

              <entry><p> <b otherprops="bold">obsoleteErrorDataFrame</b> </p></entry>

              <entry><p>This
              Obsolete Data Frame request is issued to Wearleveling Manager to
              obsolete the current data frame that failed. Then go back to the
              internal operation after step 11 to start a new writing process
              .</p> <p>There are three different cases for
              write error handling:</p> <p>1. Write error
              happens on lower page. Lookup Manager will notify Wearleveling
              Manager to obsolete the current data frame and rewrite the data
              frame to another location.</p> <p>2. Write
              error happens on upper page. Lookup Manager will notify
              Wearleveling Manager to obsolete the data frames held in the
              lower page and the current data frame and then rewrite both the
              lower and upper pages to a different location.</p> </entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">16</b></p></entry>

              <entry><p> <b otherprops="bold">BufferFree</b>
              </p></entry>

              <entry><p>When no
              longer needed the Lookup Manager frees the Data Frame buffer.
              Depending on the flash configuration (that is, MLC flash with
              gaps in shared pages), this could mean that the buffer being
              freed is for the previous flash completions. </p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">17</b> </p></entry>

              <entry><p> <b otherprops="bold">ObsoleteDataFrame</b> </p></entry>

              <entry><p>The Obsolete
              Data Frame request is issued to the Wearleveling
              Manager</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">18</b> </p></entry>

              <entry><p> <b otherprops="bold">moveOutPosted</b>
              </p></entry>

              <entry><p>The Lookup
              Manager issues a memory write request to the data network to
              update lookup table entry with new flash address.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">19</b> </p></entry>

              <entry><p> <b otherprops="bold">LockRelease</b>
              </p></entry>

              <entry><p>When all
              Data Frames have been transferred, the Data Manager releases the
              LBA range lock.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">20</b> </p></entry>

              <entry><p> <b otherprops="bold">CplQueueUpdate</b>
              </p></entry>

              <entry><p>The Data
              Manager sends a completion queue update request to the
              Completion Manager.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">21</b> </p></entry>

              <entry><p> <b otherprops="bold">CplQueueUpdateCpl</b> </p></entry>

              <entry><p>The
              Completion Manager replies back to the Admin Command Manager
              when the completion has been successfully sent to the
              host.</p></entry>
            </row>
          </tbody>
        </tgroup>
      </table></section>
  </body>
</topic>