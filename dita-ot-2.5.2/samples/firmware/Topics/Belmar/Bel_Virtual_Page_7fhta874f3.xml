<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysSchema/dita/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="Virtual_Page_7fhta874f3" xml:lang="en-US">
  <title>Virtual Page</title>

  <body>
    <p>Virtual page is a firmware construct that maximizes
    flash page usage in situations where the ECC chunk-protected data size is
    not aligned with the data frame size. A virtual page is constructed from
    the same page offset within a virtual block. A virtual block is created by
    combining multiple interleaved flash blocks to give the best performance.
    It does this by using the next plane for multi-plane operations and using
    the next channel/target for single-plane. A virtual target is created by
    combining multiple physical flash targets.</p>

    <p>Data frame size is set to 4096 Bytes of user data +
    64 Bytes of end-to-end protection + 16 Bytes of metadata, but the ECC
    chunk-protected data size varies depending on the ECC context that is
    chosen. The ECC context has the protected data size per ECC chunk, which
    translates to either more or less bytes protected per ECC chunk. The
    effect of having more bytes protected per ECC chunk is that the data frame
    might not fit in one ECC chunk.<i> <xref href="#Virtual_Page_7fhta874f3/Virtual_Page_Example_x_7ghta874f3"> </xref>
    </i>illustrates a flash page, user data in a data frame, a virtual page
    containing four flash pages, and a flash page containing two ECC chunks.
    Even though one flash page contains two ECC chunks, one flash page can
    only contain one full data frame and one partial data frame. This is
    because the ECC chunk does not necessarily hold 4KB of user data. In the
    example below, the ECC chunk holds less than 4KB of user data.</p>

    <fig id="Virtual_Page_Example_x_7ghta874f3">
      <title>Virtual Page Example x</title>

      <image href="Graphics/bel_lkp_virtual_page_example_x.svg" placement="break" width="5.5in"/>
    </fig>

    <p>The example above shows a data frame is not aligned
    to the flash page, which means a flash page may contain a full data frame
    and/or partial data frame. In turn, a data frame can span two physical
    pages. This is done to minimize the unused data area; however, the
    downside is the lookup for each data frame is a bit more complex. The
    lookup table entry needs to contain the following information:</p>

    <p><ul>
        <li id="d1e138"><p>Whether the
        data frame spans multiple flash pages.</p></li>

        <li id="d1e144"><p>The offset
        within the page where the data frame starts.</p></li>

        <li id="d1e150"><p>If there is
        a bad block within the virtual page, where to find the next portion of
        the data frame.</p></li>
      </ul></p>

    <p>The following diagrams contain some examples of how
    data frames fit within a virtual page. As shown below, the data frame
    offsets within the virtual page are fixed.</p>

    <fig id="Virtual_Page_Example_a_7hhta874f3">
      <title>Virtual Page Example a</title>

      <image href="Graphics/bel_lkp_virtual_page_example_a.svg" placement="break" width="5.5in"/>
    </fig>

    <ul>
      <li id="d1e176"><p>Virtual page a
      - Full virtual page. This condition is reached if the next user data
      exists before the timer in the Lookup Manager expires. The Lookup
      Manager receives a write request of DF0, processes that request, and
      waits for the next data frame. If DF1 is received before the timer
      expires, then the Lookup Manager packages DF0 and a portion of DF1 to
      create a page flash write request to the Write Manager. Similarly, DF2
      contains a portion of DF1 and a portion of DF3, DF4 contains a portion
      of DF3, and DF5 contains a portion of DF4 to create a page flash
      write.</p></li>

      <li id="d1e199"><p>Virtual page b
      - partial virtual page. This condition happens because a DF0 request is
      received and processed by the Lookup Manager and then the timer in the
      Lookup Manager is started to wait for the next user data. The timer
      expires and there is no user data waiting to be processed. At this
      point, the Lookup Manager will send DF0 and preset data to fill a flash
      page write. Similarly, a DF1 request is received and processed and there
      is no pending user data when the timer expires. Preset data will be sent
      along with DF1 to complete a page 1 write. A DF2 request is received,
      and since there is not enough space in page two, this page is written
      with preset data and a portion of DF2. The leftover portion of DF2 is
      now waiting for the next user data. DF3 is received by the Lookup
      Manager; since there is a partial DF2, page three is written with a
      portion of DF2 and DF3.</p></li>

      <li id="d1e223"><p>Virtual page c
      - partial virtual page. This example is similar to Virtual page b. The
      only difference is that DF1 is pending before the timer in the Lookup
      Manager expires after processing DF0. Therefore, DF0 and a portion of
      DF1 is written to page zero, and since no more user data is pending, the
      leftover portion of DF1 and the preset data is written to page
      one.</p></li>
    </ul>

    <fig id="Virtual_Page_Example_b_7ihta874f3">
      <title>Virtual Page Example b</title>

      <image href="Graphics/bel_lkp_virtual_page_example_b.svg" placement="break" width="5.5in"/>
    </fig>

    <fig id="Virtual_Page_Example_c_7jhta874f3">
      <title>Virtual Page Example c</title>

      <image href="Graphics/bel_lkp_virtual_page_example_c.svg" placement="break" width="5.5in"/>
    </fig>
  </body>
</topic>