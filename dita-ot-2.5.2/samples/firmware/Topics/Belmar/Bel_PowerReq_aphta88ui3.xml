<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysSchema/dita/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="PowerReq_aphta88ui3" xml:lang="en-US">
  <title>PowerReq</title>

  <body>
    <p>The Lookup Manager sends <apiname>PowerReq</apiname>
    to make FTL data structures to be ready for normal operation. The
    Wearleveling manager performs necessary operations depending on the power
    up state. The possible power states are:</p>

    <ul>
      <li id="d1e442"><p>First time
      power up initialization</p></li>

      <li id="d1e448"><p>Normal Power
      up Initialization</p></li>

      <li id="d1e454"><p>Power up
      initialization with recovery</p></li>
    </ul>

    <section id="First_Time_Power_Up_Initialization_aqhta88ui3"><title>First Time Power Up Initialization</title><p>It indicates that the system is powered up for the
    first time and FTL data structures need to be initialized from scratch.
    The following operations are performed during first time power up
    initialization:</p><ul>
        <li id="d1e471"><p>Identify
        factory marked bad blocks</p></li>

        <li id="d1e477"><p>Create and
        store virtual block information</p></li>

        <li id="d1e483"><p>Initialize
        valid data frame bitmap</p></li>

        <li id="d1e489"><p>Initialize
        wearleveling parameters</p></li>

        <li id="d1e495"><p>Create block
        management lists</p></li>
      </ul></section>

    <section id="Identify_Factory_Marked_Bad_Blocks_arhta88ui3"><title>Identify Factory Marked Bad Blocks</title><p>NAND flash devices are erased when they are shipped
    from the factory. The factory identifies invalid blocks before shipping
    and programs data other than FFh into a well known location. For example,
    The Micron MT29F128G08 Flash device has the first spare byte in the first
    page of the each block programmed to be 00h to indicate that the block is
    bad. <xref href="#PowerReq_aphta88ui3/Bad_Block_Marker_ashta88ui3"/> shows a bad
    block marker for different vendors. The bad blocks must not be used to
    store any data to avoid data corruption.</p><table id="Bad_Block_Marker_ashta88ui3">
        <title>Bad Block Marker</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="40*"/>

          <colspec colname="c2" colwidth="60*"/>

          <thead>
            <row>
              <entry>Vendor</entry>

              <entry>Bad Block Marker</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><p> <b otherprops="bold">Micron</b>
              </p></entry>

              <entry><p>First spare
              byte in the first page of the each block is 00h.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">Samsung</b>
              </p></entry>

              <entry><p>First spare
              byte in first or second page of a block is non-FFh.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">ONFI 1.0, 2.0</b>
              </p></entry>

              <entry><p>At least one
              byte in the spare area of the first or last page of a block is
              00h.</p></entry>
            </row>

            <row>
              <entry><p> <b otherprops="bold">Numonvx</b>
              </p></entry>

              <entry><p>First spare
              byte in the last page of a block is non-FFh.</p></entry>
            </row>
          </tbody>
        </tgroup>
      </table> <p>In order to identify all the bad blocks
    during the initial system initialization, all blocks in the system must be
    scanned. The Control Manager and the Journal Managers are responsible for
    control partition and snapshot partition blocks, and the Wearleveling
    manager scans remaining blocks. The scanning algorithm for ONFI 2.0
    devices is shown below.</p><codeblock>for (block = 0; block &lt; TOTAL_BLOCKS; block++) 
{
             // Send a flash read request to read first page metadata.
             // Validate page metadata.
             // If metadata has atleast one 0x00, mark block as bad.
}</codeblock><p>Depending on the NAND flash vendor, the
    corresponding scan algorithm is executed. In order to reduce power up
    initialization time, bad block scanning is done for all physical blocks in
    a virtual block in parallel.</p></section>

    <section id="Create_and_Store_Virtual_Block_Informati_athta88ui3"><title>Create and Store Virtual Block
    Information</title><p>Virtual block information is
    created with default values which consist of:</p><ul>
        <li id="d1e609"><p>Virtual
        block state: represents the state of virtual block. </p></li>
      </ul><p>The following virtual block states are
    supported:</p><ul>
        <li id="d1e621"><p>ERASED -
        It’s a free virtual block and ready for write.</p></li>

        <li id="d1e627"><p>ACTIVE -
        Virtual block is opened for writes.</p></li>

        <li id="d1e633"><p>USED -
        Virtual block is closed and has valid data frames.</p></li>

        <li id="d1e639"><p>GARBAGE_COLLECTION - Garbage collection is in
        progress</p></li>

        <li id="d1e645"><p>BAD -
        Virtual block is bad. It is not marked as bad until more than 50% of
        physical blocks are bad in a virtual block</p></li>

        <li id="d1e652"><p>Flash
        addr</p></li>
      </ul><p>As shown in <xref href="#PowerReq_aphta88ui3/Flash_Address_format_auhta88ui3"/>, Flash Addr
    is a combination of channel, target, LUN, block, plane, and page.
    Bits[23:0] represent NAND row address and Bits[31:24] contain channel and
    target numbers.</p><fig id="Flash_Address_format_auhta88ui3">
        <title>Flash Address format</title>

        <image href="Graphics/flash_address_format.svg" placement="break" width="5.5in"/>
      </fig> <ul>
        <li id="d1e679"><p>Bad block
        bitmap</p> <p>Bad block bitmap represents bad
        blocks in a virtual block. If a bit is clear, it is considered as a
        bad block. It is initialized to all 1s by default and updated if a bad
        block is identified through a bad block scan.</p></li>

        <li id="d1e688"><p>Grown bad
        block bitmap</p> <p>Grown bad block bitmap
        represents bad blocks in a virtual block that are identified during
        normal operation (read/write operations). It is valid until garbage
        collection is performed on this virtual block. Once garbage collection
        is completed, bad block bitmap is updated from grown bad blocks and
        grown bad block bitmap is initialized to all 1’s.</p></li>

        <li id="d1e697"><p>Valid data
        frame count</p> <p>Valid data frame count
        represents the number of valid data frames in a virtual block. It is
        calculated with the following formula.</p> <p>valid
        data frame count = virtual block size * # of pages per physical block
        * # of data frames per virtual page.</p></li>

        <li id="d1e709"><p>Erase
        count</p> <p>Erase count represents the number of
        times the virtual block is erased. It is initialized with the default
        value (1).</p></li>
      </ul></section>

    <section id="Initialize_Valid_Data_Frame_Bitmap_avhta88ui3"><title>Initialize Valid Data Frame Bitmap</title> <p>Valid data frame bitmap represents valid data frames
    within a virtual block, one bit for every data frame. 0 indicates the data
    frame is invalid; 1 indicates valid. Valid data frame bitmap is used
    during garbage collection to move all valid data frames to a new block. It
    is initialized with 1’s assuming all data frames are valid in a virtual
    block.</p></section>

    <section id="Initialize_Average_Erase_Counter_awhta88ui3"><title>Initialize Average Erase Counter</title> <p>Average Erase Counter is used in the priority
    calculation to re-arrange blocks in the usedBlockList. It is initialized
    to 1 (default value) and subsequent updates are done with the following
    formula.</p> <codeblock>                             Total erases in a virtual target
Average Erase Counter =    ----------------------------------------------
                               # of flash blocks in a virtual target</codeblock></section>

    <section id="Create_Block_Management_Lists_axhta88ui3"><title>Create Block Management Lists</title> <p>Block management lists are used to arrange the blocks
    in order based on the block state. The following block management lists
    are created.</p> <ul>
        <li id="d1e751"><p>Free Block
        List</p> <p>It is a doubly linked list used to
        access free blocks. There is a separate list for each virtual target,
        and next and prev pointers will point to the first and last free
        blocks. A block is removed from head of the list when it is opened for
        write and added to the tail when it is erased (after garbage
        collection).</p></li>

        <li id="d1e760"><p>Garbage
        Block List</p> <p>It is a doubly linked list that
        contains blocks that are ready for immediate garbage collection. There
        is a separate list for each virtual target, and next and prev pointers
        will point to first and last blocks. There are no garbage collection
        blocks for first time power up initialization, and it will be
        initialized as empty lists; that is, prev and next pointers will point
        to itself.</p></li>

        <li id="d1e769"><p>Bad Block
        List</p> <p>The Bad Block List is used to store the
        bad blocks. There is a separate list for each virtual target, and next
        and prev pointers will point to first and last bad blocks.There are no
        bad blocks for first time power up initialization, and it will be
        initialized as empty lists. Virtual block is added to the bad block
        list if the number of bad blocks is greater than 50% of virtual block
        size.</p></li>

        <li id="d1e778"><p>Used Block
        List</p> <p>It is a doubly linked list used to
        access used blocks. Each virtual target has multiple used block lists
        based on based on valid data frame count and erase count(priority).
        Next and prev pointers will point to first and last used blocks having
        the same priority. There are no used blocks for first time power up
        initialization and it will be initialized as empty lists. The
        <draft-comment audience="PMCInternal" translate="no">***ADD XREF****
        </draft-comment>Priority Based Algorithm section has more details of
        used block list management.</p></li>
      </ul> <p><xref href="#PowerReq_aphta88ui3/FreeList_ayhta88ui3"/> shows an example of free
    list and same notation is used for other lists.</p> <fig id="FreeList_ayhta88ui3">
        <title>FreeList</title>

        <image href="Graphics/freelist_belmar.svg" placement="break" width="5.5in"/>
      </fig></section>

    <section id="Normal_Power_Up_Initialization_azhta88ui4"><title>Normal Power Up Initialization</title> <p>Normal power up state indicates that the FTL data
    structures, such as block information, valid data frame count, etc, have
    been updated from the snapshots, and the Wearleveling Manager has to
    validate them and construct flash block management lists. Depending on the
    block state, blocks will be added to the corresponding list as shown in
    <xref href="#PowerReq_aphta88ui3/List_Initialization_b0hta88ui4"/>.</p> <table id="List_Initialization_b0hta88ui4">
        <title>List Initialization</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="35*"/>

          <colspec colname="c2" colwidth="65*"/>

          <thead>
            <row>
              <entry>Block State</entry>

              <entry>Operation</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><p>ERASED</p></entry>

              <entry><p>Block will
              be added to the tail of free block list.</p></entry>
            </row>

            <row>
              <entry><p>USED</p></entry>

              <entry><p>Block’s
              priority is calculated based on erase count and valid data frame
              count and added to the tail of corresponding priority
              list.</p></entry>
            </row>

            <row>
              <entry><p>ACTIVE</p></entry>

              <entry><p>It means the
              system was powered down before closing the virtual block. The
              Wearleveling Manager reads first page of block to make sure it
              is empty block or written. If it is an empty block, block state
              is changed to ERASED and added to the free block list.
              Otherwise, the block is added to tail of high priority list.
              Number of valid data frame count is not known for this block and
              hence priority of this block cannot be calculated. It is added
              to the high priority list.</p></entry>
            </row>

            <row>
              <entry><p>BAD</p></entry>

              <entry><p>Block will
              be added to the bad block list.</p></entry>
            </row>

            <row>
              <entry><p>GARBAGE_COLLECTION</p></entry>

              <entry><p>Added to the
              tail of garbage block list.</p></entry>
            </row>
          </tbody>
        </tgroup>
      </table></section>

    <section id="Power_Up_Initialization_with_Recovery_b1hta88ui4"><title>Power Up Initialization with Recovery</title> <p>This power up type indicates that the FTL data
    structure has been restored from the last written good snapshot. The
    Wearleveling Manager performs the following operations to recover the
    system data.</p> <ol>
        <li id="d1e908"><p>Reads last
        page of every flash block and gets sequence number from the controller
        metadata.</p></li>

        <li id="d1e914"><p>If sequence
        number is FFFFFFFFh:</p> <ul>
            <li id="d1e921"><p>This
            block could be erased block or partially written block.</p></li>

            <li id="d1e927"><p>Read
            first page of this block and validate sequence number.</p></li>

            <li id="d1e933"><p>If
            sequence number is FFFFFFFFh, block is marked as erased. Otherwise
            continue with step 3.</p></li>
          </ul></li>

        <li id="d1e941"><p>if sequence
        number is less than snapshot sequence number</p> <ul>
            <li id="d1e948"><p>Block
            information is up to date.</p></li>

            <li id="d1e954"><p>Continue
            with next block.</p></li>
          </ul></li>

        <li id="d1e962"><p>if sequence
        number is greater than snapshot sequence number</p> <ul>
            <li id="d1e969"><p>All
            pages of this block are scanned.</p></li>

            <li id="d1e975"><p>Lookup
            table entry is updated if existing lookup table entry is not
            valid.</p></li>

            <li id="d1e981"><p>If
            existing lookup table entry is valid, another flash read operation
            is performed to find out which one is most recently
            written.</p></li>

            <li id="d1e987"><p>After
            scanning all pages, Block information (block state and valid data
            frame count) is updated.</p></li>
          </ul></li>
      </ol></section>
  </body>
</topic>