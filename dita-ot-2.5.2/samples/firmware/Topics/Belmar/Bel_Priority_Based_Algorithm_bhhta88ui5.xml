<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysSchema/dita/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="Priority_Based_Algorithm_bhhta88ui5" xml:lang="en-US">
  <title>Priority Based Algorithm</title>

  <body>
    <p>As mentioned earlier, a used block list contains
    used blocks and must be sorted with a valid data frame count and erase
    count so that the garbage collection can select the best used block. In
    order to reduce the processing time to sort the used blocks, a used block
    list is expanded to multiple lists as shown in <xref href="#Priority_Based_Algorithm_bhhta88ui5/Used_Block_List_to_Priority_List_Mapping_bihta88ui5"/>.</p>

    <fig id="Used_Block_List_to_Priority_List_Mapping_bihta88ui5">
      <title>Used Block List to Priority List
      Mapping</title>

      <image href="Graphics/bel_wrlevl_used_blk_priority_list.svg" placement="break" width="5.5in"/>
    </fig>

    <p>The priority based algorithm assigns a priority to
    the used block based on the block’s erase counter, number of valid data
    frames in a block, and average erase count. Priority is assigned when:</p>

    <ul>
      <li id="d1e2707"><p>a flash block
      is added to the used block list.</p></li>

      <li id="d1e2713"><p>a data frame
      is obsoleted.</p></li>
    </ul>

    <p>As shown in <xref href="#Priority_Based_Algorithm_bhhta88ui5/Priority_Calculation_bjhta88ui5"/>,
    the priority is designed in such a way to pick the block with the least
    number of pages to copy and a lower erase count compared to an average
    count.</p>

    <fig id="Priority_Calculation_bjhta88ui5">
      <title>Priority Calculation</title>

      <codeblock>Priority = VDFC + Erase Weight
VDFC 
Valid Data Frame Count/CONST

Erase Weight
                   = 0                     for 0 &lt;= D &lt;= 15
                   = 1/32 D            for 16 &lt;= D &lt;= 31
                   = 1/16 D            for 32 &lt;= D &lt;= 47
                   = 3/32 D            for 48 &lt;= D &lt;= 63
                   = 1/8 D             for 64 &lt;= D &lt;= 79   
                   = 5/32 D            for 80 &lt;= D  &lt;= 95  
                   = 3/16 D            for 96 &lt;= D &lt;= 111   
                      …………….
                      …………….
                    15/16 D            for 480 &lt;= D &lt;= 485
                    31/32 D            for 496 &lt;= D &lt;= 511
                          D            for 512 &lt;= D
</codeblock>
    </fig>

    <parml>
      <plentry>
        <pt>VDFC</pt>

        <pd>A valid data frame count is taken from the block information. In
        case of true random write, priority is driven by VDFC. In order to
        reduce the list move operations (moving block one priority list to
        another), VDFC is divided by constant example : 8. It means blocks
        having data frames 0 to 7 have the same priority. VDFC plays a big
        role in selecting a block for garbage collection. When there are less
        valid data frames to copy, less flash bandwidth is used and hence the
        higher system performance.</pd>
      </plentry>

      <plentry>
        <pt>Erase Weight</pt>

        <pd>Erase Weight is measured as the distance between virtual target
        average erase count and erase count. There are two constants used in
        erase weight calculation, ERASE_DISTANCE(16), WEIGHT_DISTANCE(32) to
        make sure distance from the average erase count is not changing the
        priority of block drastically so that more preference is given to
        valid data frame count in priority calculation. When the erase count
        is falling behind from the average erase count further and further,
        the priority becomes higher and eventually it is selected for garbage
        collection, even though all pages within the block may be valid.</pd>
      </plentry>
    </parml>

    <fig id="Priority_Example_bkhta88ui5">
      <title>Priority Example</title>

      <image href="../../Graphics/Wearleveling_Mgr/priority_calculation.svg" placement="break" width="5.5in"/>
    </fig>

    <p>As shown in <xref href="#Priority_Based_Algorithm_bhhta88ui5/Priority_Calculation_bjhta88ui5"/>,
    Block with VDFC = 32 and the block with VDFC=256 have the same priority.
    Since the erase count of block with VDFC=256 is far below average, it’s
    selected for garbage collection even though it has more valid data frames.
    In this example, maximum erase count distance from average erase count is
    512, and it can be configured to 256 or 1024 or more.</p>

    <p>The following sections describe how the priority
    based algorithm addresses dynamic and static wearleveling.</p>

    <section id="Dynamic_Wearleveling_blhta88ui5"><title>Dynamic
    Wearleveling</title><p>In PMC NVM controller firmware,
    Dynamic Wearleveling is addressed by selecting a block for garbage
    collection that have the fewest erase counts and then adding it to the
    free block list; that is, thefree block list contains the blocks that have
    the fewest erase counts.</p></section>

    <section id="Static_Wearleveling_bmhta88ui5"><title>Static
    Wearleveling</title><p>Static data is never overwritten
    and the pages (or data frames) are never obsoleted; that is, all pages are
    valid. But the priority based algorithm is triggered when a data frame is
    obsoleted or new block is added to the used block list.</p> <p audience="PMCInternal"> <draft-comment translate="no">What happens to a block that
    has all static data and no pages are obsoleted? When to change priority of
    the static block?</draft-comment> </p><p>When the
    average erase count goes up by 1, the priority of a block may remain the
    same, or go up or down by 1, 2, 4, 8 or higher depending upon its erase
    count distance from the average erase count. The priority of all blocks
    within the PriorityList has to be recalculated and hence re-sorted. This
    takes up too many CPU cycles.</p><p>In order to change
    the static block priority without using too many cycles, change priority
    (decrement by 1) of every flash block when the average erase count goes up
    by 1. For instance, flash blocks having priority 511 will be changed to
    priority 510, flash blocks having priority 1 will be changed to priority 0
    and a flash block having priority zero will remain at zero priority. When
    a data frame is obsoleted, the priority of the flash block may remain the
    same, or go up or down by 1, 2, 4, 8 or higher depending upon its erase
    count distance from the average erase count and valid data frame count.
    Static block priority is decremented with the average erase count and
    selected for garbage collection.</p><p>There are two
    ways in which priority of a flash block can be changed:</p><ul>
        <li>One way is moving entries from one priority list to other priority
        list without recalculating the priority; that is, moving entries from
        priority 1 list to priority 0 list and so on. This also takes up too
        many CPU cycles.</li>

        <li>Another way is changing mapping of priority and PriorityList
        index. As shown in <xref href="#Priority_Based_Algorithm_bhhta88ui5/Priority_Example_bkhta88ui5"/>,
        the priority based algorithm uses priority as the index to the
        PriorityList to add or remove or move entries in the list. Now
        PriorityList index is calculated based on priority and average erase
        count. There is no change in the priority calculation algorithm
        described in Priority Based Algorithm.</li>
      </ul><p>The following formula is used to calculate
    PriorityList index</p><p><codeph>PriorityList Index =
    Mod of ((priority + average erase count), Max Number of
    priorities)</codeph></p><table id="PriorityList_Index_bnhta88ui5">
        <title>PriorityList Index</title>

        <tgroup cols="3">
          <colspec colname="c1" colwidth="33*"/>

          <colspec colname="c2" colwidth="33*"/>

          <colspec colname="c3" colwidth="34*"/>

          <thead>
            <row>
              <entry>Priority</entry>

              <entry>Average Erase Count</entry>

              <entry>PriorityList Index</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><p>0</p></entry>

              <entry><p>0</p></entry>

              <entry><p>0</p></entry>
            </row>

            <row>
              <entry><p>511</p></entry>

              <entry><p>0</p></entry>

              <entry><p>511</p></entry>
            </row>

            <row>
              <entry><p>0</p></entry>

              <entry><p>1</p></entry>

              <entry><p>1</p></entry>
            </row>

            <row>
              <entry><p>511</p></entry>

              <entry><p>1</p></entry>

              <entry><p>0</p></entry>
            </row>
          </tbody>
        </tgroup>
      </table> <p>With this algorithm, PriorityList index
    is changing with the average erase count. As shown in <xref href="#Priority_Based_Algorithm_bhhta88ui5/PriorityList_Index_bnhta88ui5"/>,
    when the average erase count is 0, priority 0 blocks are accessed with
    priorityListIndex 0. When it is 1, the same priority blocks are accessed
    with priorityListIndex 1. Now PriorityListIndex 0 belongs to priority 511
    blocks so all flash blocks at index 0 are moved to the head of flash
    blocks at index 1.</p><p><xref href="#Priority_Based_Algorithm_bhhta88ui5/Priority_Example_bkhta88ui5"/>
    and <xref href="#Priority_Based_Algorithm_bhhta88ui5/PriorityList_When_Average_Erase_Count_On_bphta88ui5"/>
    show the priority of flash blocks before and after the average erase count
    goes up by 1.</p><fig id="PriorityList_When_Average_Erase_Count_Ze_bohta88ui5">
        <title>PriorityList When Average Erase Count =
        Zero</title>

        <image href="Graphics/clip_image028_b3iodpt.png" placement="break"/>
      </fig> <fig id="PriorityList_When_Average_Erase_Count_On_bphta88ui5">
        <title>PriorityList When Average Erase Count =
        One</title>

        <image href="Graphics/clip_image030_b3iodpt.png" placement="break"/>
      </fig> <p>When the average erase count goes up by 1,
    the priority of every flash block is decremented without moving entries
    from one priority list to another priority list and without manipulating
    block information.</p></section>
  </body>
</topic>