<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA 1.2 Topic//EN" "/SysConfig/backup/dtd/technicalContent/dtd/topic.dtd">
<topic xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" base="Princeton" id="Data_Manager_Data_Structures_4eht98nxzd" xml:lang="en-US">
  <title>Data Manager Data Structures</title>

  <body>
    <p>The following sections describe the data structures
    utilized by the Data Manager.</p>

    <section id="Data_Frame_Buffers_4fht98nxzd"><title>Data
    Frame Buffers</title> <p>A Data Frame is 66 memory
    lines (66x64=4224B) in size and contains either 8 x 512B host logical
    blocks or 1 x 4KB host logical block, protection information, and
    controller metadata. A Data Frame is the smallest amount of data that may
    be read via the Flash Interface, writing to the flash is always performed
    on a page basis. The Control Manager initializes the Buffer Manager with
    pointers to Data Frame buffers located in controller memory during system
    initialization. These buffers are then allocated on an as-needed basis and
    used to store flash read/write data. When the Data Frame buffers are no
    longer needed they are freed back to the Buffer Manager. Data Frame
    buffers need not be freed by the same manager that allocated
    them.</p></section>

    <section id="State_Header_Structure_4ght98nxzd"><title>State
    Header Structure</title> <p>The two main data
    structures used by the Data Manager (the<xref href="#Data_Manager_Data_Structures_4eht98nxzd/Command_State_Structure_4kht98nxzd">
    Command State Structure</xref> and the <xref href="#Data_Manager_Data_Structures_4eht98nxzd/Data_Frame_State_Structure_4mht98nxzd">Data
    Frame State Structure</xref>) both contain a header structure to store
    generic state information. This structure is described in <xref href="#Data_Manager_Data_Structures_4eht98nxzd/State_Header_Structure_4hht98nxzd"/>.</p>
    <fig id="State_Header_Structure_4hht98nxzd">
        <title>State Header Structure</title>

        <image href="Graphics/clip_image002_az4daij.png" placement="break"/>
      </fig> <ul>
        <li id="d1e463"><p>list</p> <ul>
            <li id="d1e470"><p>List
            head used to queue the parent structure on various lists.</p></li>
          </ul></li>

        <li id="d1e478"><p>state</p>
        <ul>
            <li id="d1e485"><p>Current
            state of the parent structure.</p></li>
          </ul></li>

        <li id="d1e493"><p>status</p>
        <ul>
            <li id="d1e500"><p>Status
            bits related to the current state. For example, if the current
            state requires IPC messages from more than one manager, this field
            is used to track which messages have been received.</p></li>
          </ul></li>
      </ul></section>

    <section id="Memory_Copy_Information_Structure_4iht98nxzd"><title>Memory Copy Information Structure</title> <p>This structure is used to maintain the context
    information for memory copy operations. Specifically, for the transfer of
    data from Controller Memory to local data RAM.</p> <fig id="Memory_Copy_Information_Structure_4jht98nxzd">
        <title>Memory Copy Information
        Structure</title>

        <image href="Graphics/clip_image004_az4daij.png" placement="break"/>
      </fig> <ul>
        <li id="d1e534"><p>source</p>
        <ul>
            <li id="d1e541"><p>Source
            address of memcopy in controller memory.</p></li>
          </ul></li>

        <li id="d1e549"><p>dest</p> <ul>
            <li id="d1e556"><p>Destination address of memcopy in local data
            RAM.</p></li>
          </ul></li>

        <li id="d1e564"><p>length</p>
        <ul>
            <li id="d1e571"><p>Length,
            in bytes, of the data to be copied.</p></li>
          </ul></li>

        <li id="d1e579"><p>nextState</p> <ul>
            <li id="d1e586"><p>The
            state to transition to before calling processState() when the data
            transfer completes.</p></li>
          </ul></li>
      </ul></section>

    <section id="Command_State_Structure_4kht98nxzd"><title>Command State Structure</title> <p>The Command State structure is used to maintain context
    information for each outstanding NVM Express command. Memory for these
    structures is statically allocated as an array of <i>command_state_t</i> structures. Each array
    element is added to a pool of free Command State structures during
    initialization.</p> <fig id="Command_State_Structure_4lht98nxzd">
        <title>Command State Structure</title>

        <image href="Graphics/clip_image006_az4daij.png" placement="break"/>
      </fig> <p>The usage of the structure members is as
    follows:</p> <ul>
        <li id="d1e627"><p>header</p>
        <ul>
            <li id="d1e634"><p>State
            header structure.</p></li>
          </ul></li>

        <li id="d1e642"><p>ipcList</p>
        <ul>
            <li id="d1e649"><p>Structure used by the Advanced IPC Message
            Network API to queue IPC message requests to other managers or
            functional units.</p></li>
          </ul></li>

        <li id="d1e657"><p>nvmCmd</p>
        <ul>
            <li id="d1e664"><p>The NVM
            command associated with this command context.</p></li>
          </ul></li>

        <li id="d1e672"><p>cmdReady64</p> <ul>
            <li id="d1e679"><p>The
            cmdReady64 IPC message associated with this command
            context.</p></li>
          </ul></li>

        <li id="d1e687"><p>pmReadyReq</p> <ul>
            <li id="d1e694"><p>The
            PMReadyReq message associated with this context.</p></li>
          </ul></li>

        <li id="d1e703"><p>lockHandle</p> <ul>
            <li id="d1e710"><p>Handle
            received from the Locking Manager.</p></li>
          </ul></li>

        <li id="d1e718"><p>startDataFrame</p> <ul>
            <li id="d1e725"><p>The
            first Data Frame for this command.</p></li>
          </ul></li>

        <li id="d1e733"><p>totalDataFrames</p> <ul>
            <li id="d1e740"><p>The
            total number of Data Frames being referenced by this command
            context.</p></li>
          </ul></li>

        <li id="d1e748"><p>prpList</p>
        <ul>
            <li id="d1e755"><p>Memory
            line pointer to a PRP list buffer in controller memory.</p></li>
          </ul></li>

        <li id="d1e763"><p>prpOffset</p> <ul>
            <li id="d1e770"><p>Local
            memory destination address for memory copy operation.</p></li>
          </ul></li>

        <li id="d1e778"><p>splitDataFrame</p> <ul>
            <li id="d1e785"><p>If not
            NULL, this field points to a split Data Frame associated with this
            command context.</p></li>
          </ul></li>

        <li id="d1e794"><p>prpListRefCount</p> <ul>
            <li id="d1e801"><p>Count of
            the number of Data Frame state structures that reference the PRP
            list associated with this command context.</p></li>
          </ul></li>

        <li id="d1e809"><p>dataFrameReqCpl</p> <ul>
            <li id="d1e816"><p>Used to
            keep track of the number of outstanding Data Frame requests and
            completions for this command.</p></li>
          </ul></li>

        <li id="d1e824"><p>pendingDataFrames</p> <ul>
            <li id="d1e831"><p>If
            non-zero this structure is in the process of being fetched from
            controller.</p></li>
          </ul></li>

        <li id="d1e839"><p>LBAIndex</p>
        <ul>
            <li id="d1e846"><p>If
            non-zero this structure is in the process of being fetched from
            controller.</p></li>
          </ul></li>

        <li id="d1e854"><p>memcpyInfo</p> <ul>
            <li id="d1e861"><p>Structure containing memory copy information
            when moving data from controller memory to local data
            RAM.</p></li>
          </ul></li>

        <li id="d1e869"><p>refreshing</p> <ul>
            <li id="d1e876"><p>If
            non-zero this structure is in the process of being fetched from
            controller.</p></li>
          </ul></li>
      </ul></section>

    <section id="Data_Frame_State_Structure_4mht98nxzd"><title>Data Frame State Structure</title> <p>Each NVM Express command is broken down into a number
    of Data Frame requests. The Data Frame State structure is used to maintain
    the context information for these requests. Memory for these structures is
    statically allocated as an array of <i>data_frame_state_t</i> structures. Each array
    element is added to a pool of free Data Frame State structures during
    initialization.</p> <fig id="Data_Frame_State_Structure_4nht98nxzd">
        <title>Data Frame State Structure</title>

        <image href="Graphics/clip_image008_az4daij.png" placement="break"/>
      </fig> <p>The usage of the structure members is as
    follows:</p> <ul>
        <li id="d1e916"><p>header</p>
        <ul>
            <li id="d1e923"><p>State
            header structure.</p></li>
          </ul></li>

        <li id="d1e931"><p>ipcList</p>
        <ul>
            <li id="d1e938"><p>Structure used by the Advanced IPC Message
            Network API to queue IPC message requests to other managers or
            functional units.</p></li>
          </ul></li>

        <li id="d1e946"><p>commandState</p> <ul>
            <li id="d1e953"><p>Pointer
            to the command state structure for this Data Frame.</p></li>
          </ul></li>

        <li id="d1e961"><p>cacheTag</p>
        <ul>
            <li id="d1e968"><p>If the
            command state has been flushed to controller memory, this is the
            tag associated with the entry.</p></li>
          </ul></li>

        <li id="d1e976"><p>logicalAddr</p> <ul>
            <li id="d1e983"><p>Logical
            block address for this Data Frame.</p></li>
          </ul></li>

        <li id="d1e992"><p>dataFrameAddr</p> <ul>
            <li id="d1e999"><p>Memory
            line address in controller memory of the Data Frame
            buffer.</p></li>
          </ul></li>

        <li id="d1e1007"><p>prp</p> <ul>
            <li id="d1e1014"><p>Each
            Data Frame may have up to two PRP’s associated with it.</p></li>
          </ul></li>

        <li id="d1e1022"><p>prpOffset</p> <ul>
            <li id="d1e1029"><p>Index
            into the PRP list and offset within the PRP for the first PRP
            entry associated with this Data Frame.</p></li>
          </ul></li>

        <li id="d1e1037"><p>startHostLBA</p> <ul>
            <li id="d1e1044"><p>Starting host LBA within the Data Frame to be
            transferred.</p></li>
          </ul></li>

        <li id="d1e1052"><p>numHostLBA</p> <ul>
            <li id="d1e1059"><p>The
            number of host LBA's within the Data Frame to be
            transferred.</p></li>
          </ul></li>

        <li id="d1e1067"><p>LBAIndex</p> <ul>
            <li id="d1e1074"><p>The
            index of the first LBA in this Data Frame as it relates to the
            total number of LBA’s to be transferred by the associated NVM
            Express command.</p></li>
          </ul></li>
      </ul></section>

    <section id="Queue_Map_Structure_4oht98nxzd"><title>Queue
    Map Structure</title> <p>The Queue Map Structure is
    used to maintain the status and mapping information between the NVM
    Express submission and completion queues. The variable <i>queueMap</i> is declared as two dimensional
    (2x129) array of type <i>queue_map_t</i> and
    maintains information for all of the submission/completion queues
    associated with both PCIe ports. The <i>queue_map_t</i> structure is shown in <xref href="#Data_Manager_Data_Structures_4eht98nxzd/Queue_Mapping_Structure_4pht98nxzd"/>.</p>
    <fig id="Queue_Mapping_Structure_4pht98nxzd">
        <title>Queue Mapping Structure</title>

        <image href="Graphics/clip_image010_az4daij.png" placement="break"/>
      </fig> <ul>
        <li id="d1e1117"><p>outStandingCommands</p> <ul>
            <li id="d1e1124"><p>The
            number of outstanding commands for this submission queue. This
            field is initialized to 0 and is incremented each time a command
            is received from a submission queue engine and decremented each
            time a completion is sent.</p></li>
          </ul></li>

        <li id="d1e1132"><p>cplQueueEngine</p> <ul>
            <li id="d1e1139"><p>ID of
            the completion queue engine.</p></li>
          </ul></li>

        <li id="d1e1147"><p>interruptEnable</p> <ul>
            <li id="d1e1154"><p>Non-zero if the interrupt bit should be set in
            the <i>cplQUpdate</i> IPC
            message.</p></li>
          </ul></li>

        <li id="d1e1165"><p>isAdminQueue</p> <ul>
            <li id="d1e1172"><p>Hint
            used to determine if the submission queue is an admin
            queue.</p></li>
          </ul></li>

        <li id="d1e1180"><p>valid</p>
        <ul>
            <li id="d1e1187"><p>Non-zero if the information for the submission
            queue is valid.</p></li>
          </ul></li>

        <li id="d1e1196"><p>deleting</p> <ul>
            <li id="d1e1203"><p>Non-zero if the mapping is being deleted. All
            commands received for the submission queue will be completed with
            an aborted status.</p></li>
          </ul></li>
      </ul> <p>The Queue Map array is updated when the
    QueueMapCreateReq or QueueMapDelReq IPC messages are received by the Data
    Manager. See <xref href="Sam_NVM_Express_Admin_Command_Processing_52ht98nxze.xml"/>.</p></section>

    <section id="Configuration_Structure_4qht98nxzd"><title>Configuration Structure</title> <p>General Data Manager configuration information such as
    the flash configuration, namespace configuration, and DDR memory map
    configuration are stored in a global variable of type <i>data_mgr_config_t</i> called <i>config</i>. The <i>data_mgr_config_t</i> structure is shown in
    <xref href="#Data_Manager_Data_Structures_4eht98nxzd/Data_Manager_Configuration_Structure_4rht98nxzd"/>.</p>
    <fig id="Data_Manager_Configuration_Structure_4rht98nxzd">
        <title>Data Manager Configuration
        Structure</title>

        <image href="Graphics/clip_image012_az4daij.png" placement="break"/>
      </fig> <ul>
        <li id="d1e1249"><p>ipcList</p>
        <ul>
            <li id="d1e1256"><p>Used by
            the advanced IPC Network API for message queuing.</p></li>
          </ul></li>

        <li id="d1e1264"><p>commandStateBase</p> <ul>
            <li id="d1e1271"><p>Base
            address in controller memory of the command state structure cache
            for this manager.</p></li>
          </ul></li>

        <li id="d1e1279"><p>tags</p>
        <ul>
            <li id="d1e1286"><p>Storage
            for the tags received in a power request IPC message.</p></li>
          </ul></li>

        <li id="d1e1294"><p>namespaceConfig</p> <ul>
            <li id="d1e1301"><p>Namespace configuration information.</p></li>
          </ul></li>

        <li id="d1e1309"><p>secDMADWord1</p> <ul>
            <li id="d1e1316"><p>Pre-calculated value used for DWord 1 in the
            sector DMA IPC messages.</p></li>
          </ul></li>

        <li id="d1e1325"><p>pciHeader</p> <ul>
            <li id="d1e1332"><p>PCIe
            header information for each PCIe port.</p></li>
          </ul></li>

        <li id="d1e1340"><p>hostMemPageSize</p> <ul>
            <li id="d1e1347"><p>The
            host's memory page size.</p></li>
          </ul></li>

        <li id="d1e1355"><p>linkDown</p> <ul>
            <li id="d1e1362"><p>When a
            link down event is detected on one of the PCIe ports, this flag is
            set to a non-zero value. The flag is reset when the admin queue
            for the associated port is created.</p></li>
          </ul></li>

        <li id="d1e1370"><p>hostLBASize</p> <ul>
            <li id="d1e1377"><p>Size,
            in bytes, of a single host LBA, including metadata.</p></li>
          </ul></li>

        <li id="d1e1385"><p>cleanDataFrameAddr</p> <ul>
            <li id="d1e1392"><p>Memory
            line pointer to data used for virgin Data Frames.</p></li>
          </ul></li>

        <li id="d1e1400"><p>tempReg64</p> <ul>
            <li id="d1e1407"><p>Temporary storage for reg64 values read from
            controller memory.</p></li>
          </ul></li>

        <li id="d1e1416"><p>tagsInUse</p> <ul>
            <li id="d1e1423"><p>Non-zero if the <i>tags</i> and <i>ipcList</i> fields are in use; that is,
            if CreateAdminCplQReq IPC message processing is in
            progress.</p></li>
          </ul></li>
      </ul> <p>During initialization, after the Data
    Manager has received the PMReadyReq IPC message from the Control Manager,
    the NVM Express namespace information will be read from a fixed location
    in controller memory and stored in the Data Manager Configuration
    Structure.</p></section>
  </body>
</topic>